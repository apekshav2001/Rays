<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rays Wallpaper</title>

    <!-- Calligraphic Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Pinyon+Script&family=Alex+Brush&family=Tangerine:wght@400;700&family=Dancing+Script:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Calligraphic Text Overlay */
        #text-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        /* Text Position Classes */
        #text-overlay.pos-top {
            align-items: flex-start;
            padding-top: 8vh;
        }

        #text-overlay.pos-center {
            align-items: center;
        }

        #text-overlay.pos-bottom {
            align-items: flex-end;
            padding-bottom: 8vh;
        }

        #custom-text {
            font-family: 'Great Vibes', 'Pinyon Script', cursive;
            font-size: clamp(3rem, 8vw, 8rem);
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            text-shadow:
                0 0 20px rgba(255, 255, 255, 0.5),
                0 0 40px rgba(255, 255, 255, 0.3),
                0 0 60px rgba(255, 255, 255, 0.2);
            letter-spacing: 0.05em;
            line-height: 1.4;
            max-width: 90%;
            animation: textGlow 4s ease-in-out infinite alternate;
            white-space: pre-line;
        }

        @keyframes textGlow {
            0% {
                text-shadow:
                    0 0 20px rgba(255, 255, 255, 0.4),
                    0 0 40px rgba(255, 255, 255, 0.2),
                    0 0 60px rgba(255, 255, 255, 0.1);
                opacity: 0.85;
            }

            100% {
                text-shadow:
                    0 0 30px rgba(255, 255, 255, 0.6),
                    0 0 50px rgba(255, 255, 255, 0.4),
                    0 0 80px rgba(255, 255, 255, 0.3);
                opacity: 1;
            }
        }

        /* Hide text if empty */
        #custom-text:empty {
            display: none;
        }
    </style>
</head>

<body>
    <!-- Text Overlay -->
    <div id="text-overlay">
        <div id="custom-text"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // =============================================================================
        // CONFIGURATION - URL Parameters & Defaults
        // =============================================================================

        const params = new URLSearchParams(window.location.search);

        const CONFIG = {
            // Performance
            particles: clamp(parseInt(params.get('particles')) || 5000, 1000, 15000),
            fps: parseInt(params.get('fps')) || 60,
            bloom: params.get('bloom') !== 'off',
            pixelRatio: Math.min(window.devicePixelRatio, 1.5),

            // Animation
            speed: clamp(parseFloat(params.get('speed')) || 0.3, 0.0, 2.0),
            motion: clamp(parseFloat(params.get('motion')) || 0.5, 0.0, 1.0), // 0 = minimal, 1 = full
            static: params.get('static') === 'on', // Freeze animation completely

            // Visuals
            baseSize: clamp(parseFloat(params.get('size')) || 2.5, 0.5, 8.0),
            bloomStrength: clamp(parseFloat(params.get('bloomStrength')) || 1.0, 0.0, 2.5),

            // Colors (theme or custom)
            theme: params.get('theme') || 'ocean',
            color1: params.get('color1') ? '#' + params.get('color1') : null,
            color2: params.get('color2') ? '#' + params.get('color2') : null,

            // Text overlay
            text: decodeURIComponent(params.get('text') || ''),
            textFont: params.get('textFont') || 'Great Vibes',
            textSize: params.get('textSize') || '8vw',
            textColor: params.get('textColor') ? '#' + params.get('textColor') : 'rgba(255, 255, 255, 0.9)',
            textPosition: params.get('textPosition') || 'center', // top, center, bottom
            textGlow: params.get('textGlow') !== 'off'
        };

        // Color presets
        const THEMES = {
            ocean: { color1: '#0066cc', color2: '#00ffcc' },
            sunset: { color1: '#ff6b35', color2: '#9b59b6' },
            forest: { color1: '#27ae60', color2: '#16a085' },
            cosmic: { color1: '#9b59b6', color2: '#e91e63' },
            fire: { color1: '#ff4500', color2: '#ffd700' },
            aurora: { color1: '#00d4ff', color2: '#7b2ff7' },
            midnight: { color1: '#1a1a2e', color2: '#4a00e0' },
            cherry: { color1: '#ff0844', color2: '#ffb199' }
        };

        // Apply theme or custom colors
        const theme = THEMES[CONFIG.theme.toLowerCase()] || THEMES.ocean;
        CONFIG.color1 = CONFIG.color1 || theme.color1;
        CONFIG.color2 = CONFIG.color2 || theme.color2;

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        // =============================================================================
        // SHADERS
        // =============================================================================

        const vertexShader = `
            uniform float uTime;
            uniform float uAmbient;
            uniform float uMotion; // 0.0 = calm, 1.0 = full motion
            uniform vec3 uColorA;
            uniform vec3 uColorB;
            uniform float uSizeMult;

            attribute float aScale;
            attribute vec3 aRandom;
            
            varying vec3 vColor;

            void main() {
                // Base spread
                float spreadX = 35.0; 
                float spreadY = 20.0;
                float spreadZ = 25.0;

                // Initial position
                vec3 basePos;
                basePos.x = (aRandom.x - 0.5) * spreadX;
                basePos.y = (aRandom.y - 0.5) * spreadY;
                basePos.z = (aRandom.z - 0.5) * spreadZ;

                vec3 pos = basePos;

                // Apply motion based on intensity
                if (uMotion > 0.0) {
                    float particlePhase = aRandom.x * 6.28318 + aRandom.y * 3.14159;
                    float orbitSpeed = 0.1 + aRandom.z * 0.15;
                    float orbitRadius = (1.0 + aRandom.y * 2.0) * uMotion;
                    
                    // Gentle orbital motion (scaled by motion intensity)
                    float t = uTime * orbitSpeed + particlePhase;
                    pos.x += cos(t) * orbitRadius;
                    pos.z += sin(t) * orbitRadius;
                    pos.y += sin(t * 0.5 + aRandom.x * 3.0) * 0.8 * uMotion;

                    // Subtle drift (scaled by motion intensity)
                    float driftX = sin(uTime * 0.15 + aRandom.y * 5.0) * 0.5 * uMotion;
                    float driftY = cos(uTime * 0.1 + aRandom.x * 4.0) * 0.3 * uMotion;
                    pos += vec3(driftX, driftY, 0.0);
                }

                // Very subtle breathing effect (always active for "alive" feeling)
                float breathe = sin(uTime * 0.3) * 0.05 * uMotion;
                pos *= (1.0 + breathe);

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // Size with subtle variation
                float sizeVariation = 1.0 + sin(uTime * 0.5 + aRandom.x * 6.28318) * 0.15 * uMotion;
                gl_PointSize = (uSizeMult * aScale * sizeVariation) * (30.0 / -mvPosition.z);
                
                // Color blending
                float pulse = sin(uTime * 0.4 + aRandom.x * 3.14159) * 0.5 + 0.5;
                float colorMix = pulse * 0.3 * uMotion + aRandom.x * 0.7;
                vColor = mix(uColorA, uColorB, clamp(colorMix, 0.0, 1.0));
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            
            void main() {
                vec2 uv = gl_PointCoord.xy - 0.5;
                float r = length(uv);
                if(r > 0.5) discard;
                float glow = 1.0 - (r * 2.0);
                glow = pow(glow, 2.0);
                gl_FragColor = vec4(vColor, glow);
            }
        `;

        // =============================================================================
        // MAIN APPLICATION
        // =============================================================================

        let camera, scene, renderer, composer, particleSystem;
        let customTime = 0;
        let lastFrameTime = 0;
        let frameInterval = 1000 / CONFIG.fps;

        const clock = new THREE.Clock();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 6);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'low-power' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(CONFIG.pixelRatio);
            document.body.appendChild(renderer.domElement);

            // Particles
            setupParticles();

            // Post-processing (optional)
            if (CONFIG.bloom) {
                setupPostProcessing();
            }

            // Events
            window.addEventListener('resize', onResize);

            // Lively Wallpaper property listener
            if (window.livelyPropertyListener) {
                window.livelyPropertyListener = handleLivelyProperty;
            }

            // Setup text overlay
            setupText();

            // Start animation
            animate();
        }

        // =============================================================================
        // TEXT OVERLAY
        // =============================================================================

        const FONTS = {
            'Great Vibes': "'Great Vibes', cursive",
            'Pinyon Script': "'Pinyon Script', cursive",
            'Alex Brush': "'Alex Brush', cursive",
            'Tangerine': "'Tangerine', cursive",
            'Dancing Script': "'Dancing Script', cursive"
        };

        function setupText() {
            const textElement = document.getElementById('custom-text');
            const overlayElement = document.getElementById('text-overlay');
            if (!textElement) return;

            // Set text content
            textElement.textContent = CONFIG.text;

            // Apply font
            const fontFamily = FONTS[CONFIG.textFont] || FONTS['Great Vibes'];
            textElement.style.fontFamily = fontFamily;

            // Apply size
            textElement.style.fontSize = CONFIG.textSize;

            // Apply color
            textElement.style.color = CONFIG.textColor;

            // Apply position
            updateTextPosition(CONFIG.textPosition);

            // Toggle glow animation
            if (!CONFIG.textGlow) {
                textElement.style.animation = 'none';
                textElement.style.textShadow = '0 0 15px rgba(255, 255, 255, 0.3)';
            }
        }

        function updateTextPosition(position) {
            const overlay = document.getElementById('text-overlay');
            if (!overlay) return;

            // Remove existing position classes
            overlay.classList.remove('pos-top', 'pos-center', 'pos-bottom');

            // Add new position class
            const posClass = 'pos-' + (position || 'center');
            overlay.classList.add(posClass);
            CONFIG.textPosition = position;
        }

        function updateText(newText) {
            const textElement = document.getElementById('custom-text');
            if (textElement) {
                textElement.textContent = newText;
                CONFIG.text = newText;
            }
        }

        function setupParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particles;

            const positions = new Float32Array(count * 3);
            const scales = new Float32Array(count);
            const randoms = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                scales[i] = Math.random();
                randoms[i * 3] = Math.random();
                randoms[i * 3 + 1] = Math.random();
                randoms[i * 3 + 2] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uAmbient: { value: 1.0 },
                    uMotion: { value: CONFIG.static ? 0.0 : CONFIG.motion },
                    uColorA: { value: new THREE.Color(CONFIG.color1) },
                    uColorB: { value: new THREE.Color(CONFIG.color2) },
                    uSizeMult: { value: CONFIG.baseSize }
                },
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function setupPostProcessing() {
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                0.4,
                0.85
            );
            bloomPass.threshold = 0.1;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
        }

        function animate(timestamp = 0) {
            requestAnimationFrame(animate);

            // Optional FPS limiting (only when fps < 60)
            if (CONFIG.fps < 60) {
                const elapsed = timestamp - lastFrameTime;
                if (elapsed < frameInterval) return;
                lastFrameTime = timestamp - (elapsed % frameInterval);
            }

            const delta = clock.getDelta();

            // Only advance time if not in static mode
            if (!CONFIG.static) {
                customTime += delta * CONFIG.speed;
            }

            if (particleSystem) {
                particleSystem.material.uniforms.uTime.value = customTime;
                particleSystem.material.uniforms.uMotion.value = CONFIG.static ? 0.0 : CONFIG.motion;
            }

            if (composer && CONFIG.bloom) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Cleanup function for proper WebGL disposal
        function cleanup() {
            if (particleSystem) {
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
                scene.remove(particleSystem);
            }
            if (renderer) {
                renderer.dispose();
                renderer.forceContextLoss();
                renderer.domElement.remove();
            }
            if (composer) {
                composer.dispose();
            }
        }

        // Listen for page unload to cleanup
        window.addEventListener('beforeunload', cleanup);

        // Lively Wallpaper calls this when wallpaper is closed
        window.livelyWallpaperPlaybackChanged = function (isPaused) {
            if (isPaused) {
                CONFIG.static = true;
            } else {
                CONFIG.static = false;
            }
        };

        // =============================================================================
        // LIVELY WALLPAPER INTEGRATION
        // =============================================================================

        function handleLivelyProperty(name, val) {
            const textElement = document.getElementById('custom-text');

            switch (name) {
                case 'particles':
                    // Would need to rebuild particle system
                    break;
                case 'fps':
                    CONFIG.fps = parseInt(val);
                    break;
                case 'theme':
                    // Lively sends dropdown index, convert to theme name
                    const themeList = ['ocean', 'sunset', 'forest', 'cosmic', 'fire', 'aurora', 'midnight', 'cherry'];
                    const themeName = typeof val === 'number' ? themeList[val] : val;
                    if (THEMES[themeName]) {
                        CONFIG.color1 = THEMES[themeName].color1;
                        CONFIG.color2 = THEMES[themeName].color2;
                        particleSystem.material.uniforms.uColorA.value.set(CONFIG.color1);
                        particleSystem.material.uniforms.uColorB.value.set(CONFIG.color2);
                    }
                    break;
                case 'bloom':
                    CONFIG.bloom = val;
                    break;
                case 'speed':
                    CONFIG.speed = parseFloat(val);
                    break;
                case 'motion':
                    CONFIG.motion = parseFloat(val);
                    break;
                case 'static':
                    CONFIG.static = val;
                    break;
                // Text properties
                case 'text':
                    updateText(val);
                    break;
                case 'textFont':
                    // Lively sends dropdown index
                    const fontList = ['Great Vibes', 'Pinyon Script', 'Alex Brush', 'Tangerine', 'Dancing Script'];
                    const fontName = typeof val === 'number' ? fontList[val] : val;
                    if (textElement && FONTS[fontName]) {
                        textElement.style.fontFamily = FONTS[fontName];
                    }
                    break;
                case 'textSize':
                    // Lively sends dropdown index
                    const sizeList = ['4vw', '6vw', '8vw', '10vw', '12vw', '15vw'];
                    const sizeVal = typeof val === 'number' ? sizeList[val] : val;
                    if (textElement) {
                        textElement.style.fontSize = sizeVal;
                    }
                    break;
                case 'textColor':
                    if (textElement) {
                        textElement.style.color = val.startsWith('#') ? val : '#' + val;
                    }
                    break;
                case 'textPosition':
                    // Lively sends dropdown index
                    const positionList = ['top', 'center', 'bottom'];
                    const posVal = typeof val === 'number' ? positionList[val] : val;
                    updateTextPosition(posVal);
                    break;
                case 'textGlow':
                    if (textElement) {
                        if (val) {
                            textElement.style.animation = 'textGlow 4s ease-in-out infinite alternate';
                        } else {
                            textElement.style.animation = 'none';
                            textElement.style.textShadow = '0 0 15px rgba(255, 255, 255, 0.3)';
                        }
                    }
                    break;
            }
        }

        // Expose for Lively
        window.livelyPropertyListener = handleLivelyProperty;

        // Auto-start immediately
        init();
    </script>
</body>

</html>